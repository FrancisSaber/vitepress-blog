import{_ as e,o as t,c,x as s,C as p,z as o,a as n,N as a,D as r}from"./chunks/framework.2919e4b3.js";const P=JSON.parse('{"title":"深入理解Typescript","description":"","frontmatter":{"title":"深入理解Typescript","author":"ccy","date":"2023-04-12","showAccessNumber":true,"categories":["Typescript"],"tags":["Typescript","类型编程"]},"headers":[],"relativePath":"write/Typescript/深入理解Typescript.md","lastUpdated":1682342857000}'),i={name:"write/Typescript/深入理解Typescript.md"},y=s("h1",{id:"概念",tabindex:"-1"},[n("概念 "),s("a",{class:"header-anchor",href:"#概念","aria-label":'Permalink to "概念"'},"​")],-1),D=a("",1),C=a("",6),F=a("",6),A=a("",1),b=s("p",null,[s("strong",null,"函数声名方式")],-1),u=a("",1),m={id:"函数逆变例子",tabindex:"-1"},d=s("a",{class:"header-anchor",href:"#函数逆变例子","aria-label":'Permalink to "<font color="orange">函数逆变例子</font>"'},"​",-1),h=a("",4),g=a("",7),B=s("ul",null,[s("li",null,"以上代码应该不会报错，因为狗是属于动物的。"),s("li",null,[n("由此推出 "),s("code",null,"Dog -> T ≤ Animal -> Dog"),n(" 再推 "),s("code",null,"[].push(Dog) ≤ [].push[Animal]"),n(" 再推 "),s("code",null,"Dog -> T ≤ Animal -> T")]),s("li",null,[n("但实际上函数参数需要是逆变的，如果 TS 强制逆变，就反推出 "),s("code",null,"Animal [] = Dog[]"),n(" 不成立")])],-1),f=a("",17),_=a("",11);function E(v,k,T,w,S,q){const l=r("font");return t(),c("div",null,[y,s("ul",null,[s("li",null,[p(l,{color:"orange"},{default:o(()=>[n("因为 TS 是鸭子类型系统，只要两个对象结构一致，就认为是同一种类型，而不需要两者的实际类型有显式的继承关系。")]),_:1})]),D]),C,s("ul",null,[F,s("li",null,[p(l,{color:"orange"},{default:o(()=>[n("按照正确的检查逻辑（上面的四种情况检查），函数的参数类型应该使用逆变的方式来进行检查，而返回值类型则是协变。")]),_:1}),A])]),s("blockquote",null,[b,p(l,{color:"orange"},{default:o(()=>[n("以下两种声名方式推荐第二章，通过开启`strictFunctionTypes`得到更加严格的类型校验")]),_:1}),u]),s("h3",m,[p(l,{color:"orange"},{default:o(()=>[n("函数逆变例子")]),_:1}),n(),d]),h,s("blockquote",null,[g,p(l,{color:"orange"},{default:o(()=>[n("函数参数协变出现在推到过程中，得出结论可以")]),_:1}),B]),f,p(l,{color:"orange"},{default:o(()=>[n("这是因为当一个类实现接口时，指挥对实例部分进行编译检查，类的静态部分不会被编译，因此需要通过实现类的静态部分")]),_:1}),_])}const I=e(i,[["render",E]]);export{P as __pageData,I as default};
