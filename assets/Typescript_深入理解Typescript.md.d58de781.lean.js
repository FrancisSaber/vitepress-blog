import{_ as e,o as t,c,x as s,C as o,z as p,a,N as n,D as r}from"./chunks/framework.2dc08907.js";const P=JSON.parse('{"title":"概念","description":"","frontmatter":{},"headers":[],"relativePath":"Typescript/深入理解Typescript.md"}'),y={name:"Typescript/深入理解Typescript.md"},D=s("h1",{id:"概念",tabindex:"-1"},[a("概念 "),s("a",{class:"header-anchor",href:"#概念","aria-label":'Permalink to "概念"'},"​")],-1),F=n("",1),C=n("",6),A=n("",6),i=n("",1),d=s("p",null,[s("strong",null,"函数声名方式")],-1),u=n("",1),g={id:"函数逆变例子",tabindex:"-1"},h=s("a",{class:"header-anchor",href:"#函数逆变例子","aria-label":'Permalink to "<font color="orange">函数逆变例子</font>"'},"​",-1),m=n("",4),B=n("",7),f=s("ul",null,[s("li",null,"以上代码应该不会报错，因为狗是属于动物的。"),s("li",null,[a("由此推出 "),s("code",null,"Dog -> T ≤ Animal -> Dog"),a(" 再推 "),s("code",null,"[].push(Dog) ≤ [].push[Animal]"),a(" 再推 "),s("code",null,"Dog -> T ≤ Animal -> T")]),s("li",null,[a("但实际上函数参数需要是逆变的，如果TS强制逆变，就反推出 "),s("code",null,"Animal [] = Dog[]"),a(" 不成立")])],-1),_=n("",17),b=n("",11);function E(k,v,T,S,w,q){const l=r("font");return t(),c("div",null,[D,s("ul",null,[s("li",null,[o(l,{color:"orange"},{default:p(()=>[a("因为 TS 是鸭子类型系统，只要两个对象结构一致，就认为是同一种类型，而不需要两者的实际类型有显式的继承关系。")]),_:1})]),F]),C,s("ul",null,[A,s("li",null,[o(l,{color:"orange"},{default:p(()=>[a("按照正确的检查逻辑（上面的四种情况检查），函数的参数类型应该使用逆变的方式来进行检查，而返回值类型则是协变。")]),_:1}),i])]),s("blockquote",null,[d,o(l,{color:"orange"},{default:p(()=>[a("以下两种声名方式推荐第二章，通过开启`strictFunctionTypes`得到更加严格的类型校验")]),_:1}),u]),s("h3",g,[o(l,{color:"orange"},{default:p(()=>[a("函数逆变例子")]),_:1}),a(),h]),m,s("blockquote",null,[B,o(l,{color:"orange"},{default:p(()=>[a("函数参数协变出现在推到过程中，得出结论可以")]),_:1}),f]),_,o(l,{color:"orange"},{default:p(()=>[a("这是因为当一个类实现接口时，指挥对实例部分进行编译检查，类的静态部分不会被编译，因此需要通过实现类的静态部分")]),_:1}),b])}const I=e(y,[["render",E]]);export{P as __pageData,I as default};
